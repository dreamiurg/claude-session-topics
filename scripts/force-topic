#!/bin/bash
# Force-generate a new topic immediately (bypasses threshold)
# Usage: force-topic [session_id]
#        If session_id not provided, uses CLAUDE_SESSION_ID environment variable

set -uo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/common.sh
source "$SCRIPT_DIR/../lib/common.sh"

readonly MAX_CHARS=${CLAUDE_TOPIC_MAX_CHARS:-50}
readonly CONTEXT_LINES=${CLAUDE_TOPIC_CONTEXT_LINES:-100}
readonly LOCK_TIMEOUT=${CLAUDE_TOPIC_LOCK_TIMEOUT:-60}
readonly CLAUDE_MEM_DB="${CLAUDE_MEM_DB:-$HOME/.claude-mem/claude-mem.db}"
readonly CLAUDE_MEM_LIMIT=${CLAUDE_TOPIC_MEM_LIMIT:-15}

# Get session ID from argument, environment, or most recent state file
session_id="${1:-${CLAUDE_SESSION_ID:-}}"

if [[ -z "$session_id" ]]; then
    # Find most recently modified state file
    latest_state=$(ls -t "${TMPDIR:-/tmp}"/claude-topic-*.json 2>/dev/null | head -1)
    if [[ -n "$latest_state" ]]; then
        # Extract session ID from filename: claude-topic-<session_id>.json
        session_id=$(basename "$latest_state" .json | sed 's/^claude-topic-//')
        debug_log "Using session from most recent state file: $session_id"
    fi
fi

if [[ -z "$session_id" ]]; then
    echo "Error: No session ID found. Pass as argument or set CLAUDE_SESSION_ID" >&2
    exit 1
fi

if ! validate_session_id "$session_id"; then
    echo "Error: Invalid session ID format" >&2
    exit 1
fi

if ! require_claude_cli; then
    echo "Error: claude CLI not available" >&2
    exit 1
fi

state_file=$(claude_state_file "$session_id")
lock_file=$(claude_lock_file "$session_id")

# Get context from claude-mem observations
get_claudemem_context() {
    local sid="$1"
    [[ ! -f "$CLAUDE_MEM_DB" ]] && return 1
    command -v sqlite3 >/dev/null 2>&1 || return 1

    local escaped_sid
    escaped_sid=$(printf '%s' "$sid" | sed "s/'/''/g")

    local result
    result=$(sqlite3 "$CLAUDE_MEM_DB" "
        SELECT type, title, subtitle
        FROM observations
        WHERE sdk_session_id = '${escaped_sid}'
        ORDER BY created_at_epoch DESC
        LIMIT ${CLAUDE_MEM_LIMIT};
    " 2>/dev/null) || return 1

    [[ -z "$result" ]] && return 1

    echo "$result" | while IFS='|' read -r type title subtitle; do
        [[ -n "$title" ]] && echo "[$type] $title: $subtitle"
    done
}

# Build prompt
build_topic_prompt() {
    local context_source="$1"
    local context_text="$2"
    local source_label context_label

    if [[ "$context_source" == "claude-mem" ]]; then
        source_label="session observations"
        context_label="Session observations"
    else
        source_label="Claude Code session"
        context_label="Recent conversation"
    fi

    cat <<EOF
Based on these ${source_label}, generate a terse topic line.

Format: "<topic>: <activity>" where:
- Topic captures the overall theme (2-4 words)
- Activity is a SHORT gerund phrase (2-3 words max, e.g., "fixing tests", "adding auth")

Examples:
- OAuth debug: fixing validation
- Blog post: adding snippets
- tmux config: wiring display
- Session topics plugin: updating README

Requirements:
- Max ${MAX_CHARS} characters total
- Keep activity part SHORT (2-3 words)
- Output ONLY the topic line, nothing else
- NEVER start with "I", "Looking", "Based", "This", or "Theme"

${context_label}:
${context_text}
EOF
}

# Try to acquire lock
if ! acquire_lock "$lock_file" "$LOCK_TIMEOUT"; then
    echo "Error: Could not acquire lock (generation already in progress?)" >&2
    exit 1
fi
trap 'release_lock "$lock_file"' EXIT

# Get context - try claude-mem first
context=""
context_source=""
if context=$(get_claudemem_context "$session_id"); then
    context_source="claude-mem"
else
    # Fall back to transcript
    transcript_path="$HOME/.claude/projects/.current-project/transcript.jsonl"
    if [[ -f "$transcript_path" ]]; then
        context=$(tail -n "$CONTEXT_LINES" "$transcript_path" 2>/dev/null |
            jq -r 'select(.type == "user" or .type == "assistant") |
                   if .type == "user" then "User: " + (.message.content // .content // "" | tostring | .[0:200])
                   elif .type == "assistant" then "Claude: " + (.message.content // .content // "" | tostring | .[0:200])
                   else empty end' 2>/dev/null |
            head -c 5000)
        context_source="transcript"
    fi
fi

if [[ -z "$context" ]]; then
    echo "Error: No context available for topic generation" >&2
    exit 1
fi

debug_log "Generating topic (source: $context_source)"
prompt=$(build_topic_prompt "$context_source" "$context")

new_topic=$(printf '%s' "$prompt" | claude --model haiku --print --no-session-persistence --tools "" 2>/dev/null | head -1)

if [[ -z "$new_topic" ]]; then
    echo "Error: Topic generation returned empty result" >&2
    exit 1
fi

# Write state
jq -n \
    --argjson count 0 \
    --arg topic "$new_topic" \
    --arg error "" \
    --argjson ts "$(date +%s)" \
    '{count: $count, topic: $topic, error: $error, generated_at: $ts}' >"$state_file"

echo "$new_topic"
