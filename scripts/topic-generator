#!/bin/bash
# Generate session topic summary using Haiku (async)
# Usage: echo '{"session_id":"abc123", "transcript_path":"..."}' | topic-generator
#
# Throttled by message count - only generates new topic every N messages
# Stores state in $TMPDIR/claude-topic-{session_id}.json
# Topic generation runs in background to avoid blocking the hook

set -uo pipefail # Removed -e to handle errors gracefully

# Source common library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/common.sh
source "$SCRIPT_DIR/../lib/common.sh"

# Configuration - all values can be overridden via environment variables
readonly THRESHOLD=${CLAUDE_TOPIC_THRESHOLD:-10}
readonly MAX_CHARS=${CLAUDE_TOPIC_MAX_CHARS:-50}
readonly CONTEXT_LINES=${CLAUDE_TOPIC_CONTEXT_LINES:-100}
readonly LOCK_TIMEOUT=${CLAUDE_TOPIC_LOCK_TIMEOUT:-60}
readonly CLAUDE_MEM_DB="${CLAUDE_MEM_DB:-$HOME/.claude-mem/claude-mem.db}"
readonly CLAUDE_MEM_LIMIT=${CLAUDE_TOPIC_MEM_LIMIT:-15}
readonly CLAUDE_TIMEOUT=${CLAUDE_TOPIC_CLAUDE_TIMEOUT:-30}

# Get context from claude-mem observations (returns empty if unavailable)
# Args: session_id - validated session identifier
# Returns: formatted observations on stdout, exit 1 if unavailable
get_claudemem_context() {
    local session_id="$1"

    # Check if database exists
    [[ ! -f "$CLAUDE_MEM_DB" ]] && return 1

    # Check if sqlite3 is available
    command -v sqlite3 >/dev/null 2>&1 || return 1

    debug_log "Querying claude-mem for session: $session_id"

    # Query observations using parameterized approach
    # Session ID is pre-validated by validate_session_id() but we escape for defense-in-depth
    local escaped_sid
    escaped_sid=$(printf '%s' "$session_id" | sed "s/'/''/g")

    local result
    result=$(sqlite3 "$CLAUDE_MEM_DB" "
        SELECT type, title, subtitle
        FROM observations
        WHERE sdk_session_id = '${escaped_sid}'
        ORDER BY created_at_epoch DESC
        LIMIT ${CLAUDE_MEM_LIMIT};
    " 2>/dev/null) || return 1

    # Check if we got any results
    [[ -z "$result" ]] && return 1

    debug_log "Found claude-mem observations"

    # Format observations as context
    echo "$result" | while IFS='|' read -r type title subtitle; do
        [[ -n "$title" ]] && echo "[$type] $title: $subtitle"
    done
}

# Build the topic generation prompt
# Args: context_source ("claude-mem" or "transcript"), context_text
# Returns: prompt string on stdout
build_topic_prompt() {
    local context_source="$1"
    local context_text="$2"
    local source_label context_label

    if [[ "$context_source" == "claude-mem" ]]; then
        source_label="session observations"
        context_label="Session observations"
    else
        source_label="Claude Code session"
        context_label="Recent conversation"
    fi

    cat <<EOF
Based on these ${source_label}, generate a terse topic line.

Format: "<topic>: <activity>" where:
- Topic captures the overall theme (2-4 words)
- Activity is a SHORT gerund phrase (2-3 words max, e.g., "fixing tests", "adding auth")

Examples:
- OAuth debug: fixing validation
- Blog post: adding snippets
- tmux config: wiring display
- Session topics plugin: updating README

Requirements:
- Max ${MAX_CHARS} characters total
- Keep activity part SHORT (2-3 words)
- Output ONLY the topic line, nothing else
- NEVER start with "I", "Looking", "Based", "This", or "Theme"

${context_label}:
${context_text}
EOF
}

# Read and validate input
input=$(cat)
if ! jq empty <<<"$input" 2>/dev/null; then
    exit 0 # Invalid JSON
fi

session_id=$(jq -r '.session_id // empty' <<<"$input")
[[ -z "$session_id" ]] && exit 0

# Validate session_id format
if ! validate_session_id "$session_id"; then
    exit 0
fi

# Skip if this is a continuation from stop hook (prevent infinite loops)
stop_hook_active=$(jq -r '.stop_hook_active // false' <<<"$input")
[[ "$stop_hook_active" == "true" ]] && exit 0

state_file=$(claude_state_file "$session_id")
lock_file=$(claude_lock_file "$session_id")

# Initialize state variables
count=0
topic=""
error=""

# Read existing state if available
if [[ -f "$state_file" ]]; then
    state=$(cat "$state_file")
    count=$(jq -r '.count // 0' <<<"$state" 2>/dev/null) || count=0
    topic=$(jq -r '.topic // ""' <<<"$state" 2>/dev/null) || topic=""
    error=$(jq -r '.error // ""' <<<"$state" 2>/dev/null) || error=""
    # Ensure count is numeric
    [[ "$count" =~ ^[0-9]+$ ]] || count=0
fi

# Increment count
count=$((count + 1))

# Write state to JSON file
# Args: count (int), topic (string), error (string)
# State file schema:
#   count: number of messages since last topic generation
#   topic: generated topic string or empty
#   error: error message or empty
#   generated_at: Unix timestamp of last write
write_state() {
    local count="$1"
    local topic="$2"
    local error="$3"
    debug_log "Writing state: count=$count, topic='$topic', error='$error'"
    jq -n \
        --argjson count "$count" \
        --arg topic "$topic" \
        --arg error "$error" \
        --argjson ts "$(date +%s)" \
        '{count: $count, topic: $topic, error: $error, generated_at: $ts}' >"$state_file"
}

# Check if we should generate a new topic
if [[ $count -ge $THRESHOLD || -z "$topic" ]]; then
    # Try to acquire lock atomically
    if ! acquire_lock "$lock_file" "$LOCK_TIMEOUT"; then
        # Lock held by another process, just update count and exit
        write_state "$count" "$topic" "$error"
        exit 0
    fi

    # Try claude-mem first (faster, richer context)
    context=""
    context_source=""
    if context=$(get_claudemem_context "$session_id"); then
        context_source="claude-mem"
    else
        # Fall back to transcript parsing
        transcript_path=$(jq -r '.transcript_path // empty' <<<"$input")
        if [[ -n "$transcript_path" ]]; then
            transcript_path=$(validate_transcript_path "$transcript_path") || transcript_path=""
        fi

        if [[ -n "$transcript_path" && -f "$transcript_path" ]]; then
            # Get last N lines, extract user/assistant messages
            context=$(tail -n "$CONTEXT_LINES" "$transcript_path" 2>/dev/null |
                jq -r 'select(.type == "user" or .type == "assistant") |
                       if .type == "user" then "User: " + (.message.content // .content // "" | tostring | .[0:200])
                       elif .type == "assistant" then "Claude: " + (.message.content // .content // "" | tostring | .[0:200])
                       else empty end' 2>/dev/null |
                head -c 5000)
            context_source="transcript"
        fi
    fi

    if [[ -n "$context" ]]; then
        # Verify claude CLI is available before spawning background process
        if ! require_claude_cli; then
            release_lock "$lock_file"
            error="claude CLI not available"
            write_state "$count" "$topic" "$error"
            exit 0
        fi

        # Run topic generation in background, fully detached to prevent orphan processes
        # Close inherited file descriptors and use timeout to prevent hangs
        (
            # Ensure lock is released on exit
            trap 'release_lock "$lock_file"' EXIT

            debug_log "Starting topic generation (source: $context_source)"

            # Build prompt using shared function (eliminates duplication)
            prompt=$(build_topic_prompt "$context_source" "$context")

            # Use timeout to prevent indefinite hangs (macOS uses gtimeout from coreutils)
            timeout_cmd=""
            if command -v timeout >/dev/null 2>&1; then
                timeout_cmd="timeout ${CLAUDE_TIMEOUT}"
            elif command -v gtimeout >/dev/null 2>&1; then
                timeout_cmd="gtimeout ${CLAUDE_TIMEOUT}"
            fi

            if [[ -n "$timeout_cmd" ]]; then
                new_topic=$(printf '%s' "$prompt" | $timeout_cmd claude --model haiku --print --no-session-persistence --tools "" 2>/dev/null | head -1)
            else
                # Fallback without timeout - rely on claude's own timeout behavior
                new_topic=$(printf '%s' "$prompt" | claude --model haiku --print --no-session-persistence --tools "" 2>/dev/null | head -1)
            fi

            # Update state file with new topic (only writer at this point due to lock)
            if [[ -n "$new_topic" ]]; then
                debug_log "Generated topic: $new_topic"
                write_state "0" "$new_topic" ""
            else
                debug_log "Topic generation returned empty"
            fi
            # Lock released by trap
        ) </dev/null >/dev/null 2>&1 &
        disown 2>/dev/null || true

        # Main process: write current state and exit immediately (don't race with background)
        # The background process will overwrite when it completes
        error=""
    else
        # No context, release lock immediately
        release_lock "$lock_file"
        error="waiting for conversation"
    fi
fi

# Write state (hook returns immediately)
write_state "$count" "$topic" "$error"
