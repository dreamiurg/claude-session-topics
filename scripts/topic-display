#!/bin/bash
# Display current session topic from state file
# Usage: topic-display [session_id]
#
# Session ID can be provided via:
#   1. Command-line argument: topic-display <session_id>
#   2. Stdin JSON (ccstatusline format): {"session_id": "..."}
#
# Returns: topic string suitable for status displays, or empty on error

set -uo pipefail

# Source common library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/common.sh
source "$SCRIPT_DIR/../lib/common.sh"

session_id="${1:-}"

# If no argument provided, try reading from stdin (ccstatusline passes JSON via stdin)
if [[ -z "$session_id" ]] && [[ ! -t 0 ]]; then
    stdin_data=$(cat)
    if [[ -n "$stdin_data" ]]; then
        session_id=$(echo "$stdin_data" | jq -r '.session_id // empty' 2>/dev/null) || session_id=""
    fi
fi

# Silent exit if no session_id
[[ -z "$session_id" ]] && exit 0

# Validate session_id format
if ! validate_session_id "$session_id"; then
    exit 0
fi

state_file=$(claude_state_file "$session_id")

# Configuration - matches topic-generator
readonly REGEN_INTERVAL=${CLAUDE_TOPIC_REGEN_INTERVAL:-10}

# Calculate next generation point (Fibonacci: 1,2,3,5,8 then every REGEN_INTERVAL)
next_generation_at() {
    local cnt="$1"
    # Fibonacci thresholds
    [[ $cnt -lt 1 ]] && echo 1 && return
    [[ $cnt -lt 2 ]] && echo 2 && return
    [[ $cnt -lt 3 ]] && echo 3 && return
    [[ $cnt -lt 5 ]] && echo 5 && return
    [[ $cnt -lt 8 ]] && echo 8 && return
    # After Fibonacci, next is at intervals of REGEN_INTERVAL from 8
    local since_fib=$((cnt - 8))
    local next_interval=$(( (since_fib / REGEN_INTERVAL + 1) * REGEN_INTERVAL ))
    echo $((8 + next_interval))
}

# If no state file yet, show helpful message
if [[ ! -f "$state_file" ]]; then
    printf 'Topic: after 1 message'
    exit 0
fi

# Read state using individual jq calls to avoid TSV parsing issues
topic=$(jq -r '.topic // ""' "$state_file" 2>/dev/null) || topic=""
error=$(jq -r '.error // ""' "$state_file" 2>/dev/null) || error=""
count=$(jq -r '.count // 0' "$state_file" 2>/dev/null) || count=0
generated_at=$(jq -r '.generated_at // 0' "$state_file" 2>/dev/null) || generated_at=0

# If we have a topic, calculate age and display
if [[ -n "$topic" && "$topic" != "null" ]]; then
    if [[ "$generated_at" -gt 0 ]]; then
        now=$(date +%s)
        age=$((now - generated_at))

        # Rough age estimates - don't count beans
        if [[ $age -lt 300 ]]; then
            age_str="now"
        elif [[ $age -lt 900 ]]; then
            age_str="~10m"
        elif [[ $age -lt 1800 ]]; then
            age_str="~20m"
        elif [[ $age -lt 3600 ]]; then
            age_str="~45m"
        elif [[ $age -lt 7200 ]]; then
            age_str="~1h"
        else
            age_str="~$((age / 3600))h"
        fi

        printf '%s (%s)' "$topic" "$age_str"
    else
        printf '%s' "$topic"
    fi
elif [[ -n "$error" && "$error" != "null" && "$error" != "waiting for conversation" ]]; then
    # Show actual errors, but not the "waiting" status
    printf '%s' "$error"
else
    # State file exists but no topic yet - show progress
    next_at=$(next_generation_at "$count")
    remaining=$((next_at - count))
    if [[ $remaining -le 0 ]]; then
        printf 'Generating topic...'
    else
        printf 'Topic: in %d messages' "$remaining"
    fi
fi
